//----------------------------------------------------------------------------
/// \file  test_config_validator.cpp
//----------------------------------------------------------------------------
/// \brief Test cases for config_validator.
//----------------------------------------------------------------------------
// Copyright (c) 2012 Serge Aleynikov <saleyn@gmail.com>
// Created: 2012-01-14
//----------------------------------------------------------------------------
/*
***** BEGIN LICENSE BLOCK *****

This file may be included in different open-source projects.

Copyright (C) 2012 Serge Aleynikov <saleyn@gmail.com>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

***** END LICENSE BLOCK *****
*/

#include <utxx/config_validator.hpp>
#include <utxx/variant_tree_parser.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string.hpp>
#include <regex>

// The file below is auto-generated by running
// config_validator.xsl on test_config_validator.xml
#include "generated/test_config_validator.generated.hpp"
#include "generated/test_config_validator2.generated.hpp"

#ifndef NO_TEST_FRAMEWORK
#include <boost/test/unit_test.hpp>
#else
#include <boost/assert.hpp>
#define BOOST_AUTO_TEST_CASE(f) void f()
#define BOOST_REQUIRE(x) BOOST_ASSERT((x))
void BOOST_REQUIRE_EQUAL(const char* x, const char* y) {
    if (strcmp(x, y)) {
        std::cerr << "Left:  '" << (x) << "'\nRight: '" << (y) << "'" << std::endl;
        BOOST_ASSERT(false);
    }
}
void BOOST_REQUIRE_EQUAL(const char* x, const std::string& y) {
    if (y != x) {
        std::cerr << "Left:  '" << (x) << "'\nRight: '" << (y) << "'" << std::endl;
        BOOST_ASSERT(false);
    }
}

void test_config_validator1();
void test_config_validator2();
void test_config_validator3();
void test_config_validator4();
void test_config_validator5();
void test_config_validator6();
void test_config_validator7();
void test_config_validator8();

int main() {
    test_config_validator1();
    test_config_validator2();
    test_config_validator3();
    test_config_validator4();
    test_config_validator5();
    test_config_validator6();
    test_config_validator7();
    test_config_validator8();
    return 0;
}

#endif


using namespace utxx;

BOOST_AUTO_TEST_CASE( test_config_find )
{
    variant_tree cfg;
    std::stringstream ss; ss <<
    "oe cme_oe0 {\n"
    "    env = \"test\""
    "}\n"
    "oe cme_oe1 {\n"
    "    env = \"test\""
    "}\n";
    read_config(ss, cfg, FORMAT_SCON);

    auto oe = cfg.get_child_optional("oe[cme_oe1]");

    BOOST_REQUIRE(oe);

    std::stringstream ss1; ss1 <<
    "interface \"NDA\" {\n"
    "    address = \"value\"\n"
    "    enabled = false\n"
    "}\n";
    variant_tree     cfg1;
    read_config(ss1, cfg1, FORMAT_SCON);
    oe->put_child("interface", cfg1.get_child("interface"));

    //std::cout << cfg.to_string() << std::endl;
    BOOST_REQUIRE(cfg.get_child_optional("oe[cme_oe1].interface.enabled"));
}

BOOST_AUTO_TEST_CASE( test_config_hash )
{
    variant_tree l_config;
    std::stringstream l_stream; l_stream
        << "def {\n"
        << "  k1 = \"abc\\#123\"\n"
        << "  k2 = \"abc123\\#\"\n"
        << "  k3 = \"\\#abc123\"\n"
        << "}\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE_EQUAL("abc#123", l_config.get("def.k1", ""));
        BOOST_REQUIRE_EQUAL("abc123#", l_config.get("def.k2", ""));
        BOOST_REQUIRE_EQUAL("#abc123", l_config.get("def.k3", ""));
    } catch (variant_tree_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

    BOOST_REQUIRE(true); // Just to avoid a warning that there are no tests
}

BOOST_AUTO_TEST_CASE( test_config_validator2 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream
        << "def  { key  = \"yahoo\" }\n"
        << "grp2 { addr = \"abc\"   }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        test::cfg_validator2::instance()->validate(l_config);
    } catch (variant_tree_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

    BOOST_REQUIRE(true); // Just to avoid a warning that there are no tests
}

BOOST_AUTO_TEST_CASE( test_config_validator10 )
{
    const test::cfg_validator* l_validator = test::cfg_validator::instance();

    std::stringstream s;
    s << l_validator->usage("", false);
    static const char* expected =
        "address: string\n"
        "  Description: Sample string entry\n"
        "      Default: \"123.124.125.012\"\n"
        "cost: float\n"
        "  Description: Sample float entry\n"
        "      Default: 1.5\n"
        "          Min: 0.0\n"
        "country: string\n"
        "  Description: Sample choice required entry\n"
        "       Unique: true\n"
        "     Required: true\n"
        "       Values: CA | Canada\n"
        "               MX |\n"
        "               US | USA\n"
        "  connection (anonymous): string\n"
        "    Description: Server connection\n"
        "        Default: \"\"\n"
        "          Names: ARCA\n"
        "                 NSDQ\n"
        "      address: string\n"
        "        Description: Server address\n"
        "           Required: true\n"
        "duration: int\n"
        "  Description: Sample required int entry\n"
        "     Required: true\n"
        "          Min: 10 Max: 60\n"
        "enabled: bool\n"
        "  Description: Sample bool entry\n"
        "      Default: true\n"
        "section: string\n"
        "  Description: First line\n"
        "               Second line\n"
        "     Required: true\n"
        "  location: int\n"
        "       Required: true\n"
        "section2: string\n"
        "  abc: string\n"
        "        Default: \"x\"\n"
        "tmp_str: string\n"
        "      Default: \"$TMP\"\n";
    std::string got(s.str());
    if (expected != got) {
        std::vector<std::string> res1, res2;
        boost::split(res1, expected, boost::is_any_of("\n"), boost::algorithm::token_compress_off);
        boost::split(res2, got, boost::is_any_of("\n"), boost::algorithm::token_compress_off);
        std::vector<std::string>::iterator it1 = res1.begin(), it2 = res2.begin();
        std::vector<std::string>::iterator e1  = res1.end(),   e2  = res2.end();
        int i = 1;
        for (; it1 != e1 && it2 != e2; ++it1, ++it2, ++i)
            if (*it1 != *it2)
                break;
        if (it1 != e1)
            BOOST_TEST_MESSAGE("Expected[" << i << "]: " << *it1);
        if (it2 != e2)
            BOOST_TEST_MESSAGE("Got     [" << i << "]: " << *it2);
    }
    BOOST_REQUIRE_EQUAL(expected, got);
}

BOOST_AUTO_TEST_CASE( test_config_validator11 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream; l_stream
        << "address \"yahoo\"\n"
        << "enabled false\n"
        << "duration 20\n"
        << "cost     2.0\n"
        << "country \"US\"\n"
        << "  {\n"
        << "    ARCA\n"
        << "    { address \"1.2.3.4\" }\n"
        << "  }\n"
        << "section {\n"
        << "  location 10\n"
        << "}\n"
        << "country \"CA\"\n"
        << "  {\n"
        << "    ARCA exchange\n" /* This is an example of an anonymous
                                    node with value 'exchange' */
        << "    { address \"1.2.3.4\" }\n"
        << "    NSDQ\n"          /* Another anonymous node */
        << "    { address \"2.3.4.5\" }\n"
        << "  }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(true); // Just to avoid a warning that there are no tests
    } catch (variant_tree_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator12 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;
    l_stream << "address \"yahoo\"\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country", e.path());
        BOOST_REQUIRE_EQUAL(
            "Config error [country]: Missing required option with no default!",
            e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator13 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;
    l_stream << "duration 10\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country", e.path());
        BOOST_REQUIRE_EQUAL(
            "Config error [country]: Missing required option with no default!",
            e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "country US { ARCA connection { address abc } }\nduration 10\n"
             << "section { location 10 }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
    } catch (variant_tree_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "country US { }\nduration 10\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(true); // TODO: throw error because country.US.connection.address is undefined
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[US]", e.path());
        BOOST_REQUIRE_EQUAL(
            "Config error [country[US]]: Option is missing required child option: connection.address",
            e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator14 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;
    l_stream << "country US { ARCA connection { address abc } }\nduration 5\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("duration[5]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [duration[5]]: Value too small!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator15 )
{
    variant_tree l_config("root", test::cfg_validator::instance());

    std::stringstream l_stream;
    l_stream << "country US { ARCA connection { address abc } }\nduration 61\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("root.duration[61]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [root.duration[61]]: Value too large!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator16 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;
    l_stream << "duration 10\n"
             << "country \"ER\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[ER]", e.path());
        BOOST_REQUIRE_EQUAL(
            "Config error [country[ER]]: Value is not allowed for option!",
            e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator17 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;

    l_stream << "duration 10\n"
             << "country \"US\"\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[US]", e.path());
        BOOST_REQUIRE_EQUAL(
            "Config error [country[US]]: Option is missing required child option: connection.address",
            e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"US\"\n"
             << "{\"ARCA\" example }\n"
             << "section { location 10 }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[US].connection.ARCA[example].address", e.path());
        BOOST_REQUIRE_EQUAL("Config error [country[US].connection.ARCA[example].address]: "
            "Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"ER\" { ARCA connection { address abc } }\n"
             << "abc test\n"
             << "section { location 10 }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[ER]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [country[ER]]: Value is not allowed for option!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "abc test\n"
             << "section { location 10 }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("abc", e.path());
        BOOST_REQUIRE_EQUAL("Config error [abc]: Unsupported config option!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n country \"US\"\n { \"\" example }\n"
             << "section { location 10 }\n";

    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("country[US].connection[example].address", e.path());
        BOOST_REQUIRE_EQUAL("Config error [country[US].connection[example].address]: "
            "Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "address abc\n address bcd\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("address[bcd]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [address[bcd]]: "
            "Non-unique config option found!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator18 )
{
    variant_tree l_config("", test::cfg_validator::instance());
    std::stringstream l_stream;

    l_stream << "address 10\nduration 15\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("address[10]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [address[10]]: "
            "Wrong type - expected string!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration abc\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("duration[abc]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [duration[abc]]: Wrong type - expected integer!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "enabled 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("enabled[1]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [enabled[1]]: "
            "Wrong type - expected boolean true/false!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("cost[1]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [cost[1]]: Wrong type - expected float!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("section", e.path());
        std::string s = e.what();
        BOOST_REQUIRE_EQUAL("Config error [section]: "
            "Missing a required child option: location", s);
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("cost[1]", e.path());
        BOOST_REQUIRE_EQUAL("Config error [cost[1]]: Wrong type - expected float!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1.0\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    try {
        read_config(l_stream, l_config, FORMAT_SCON);
    } catch (variant_tree_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

}

BOOST_AUTO_TEST_CASE( test_config_validator_def )
{
    const test::cfg_validator* l_validator = test::cfg_validator::instance();
    BOOST_REQUIRE_EQUAL("test", l_validator->root().dump());
    BOOST_REQUIRE_EQUAL(variant("123.124.125.012"), l_validator->def("test.address").data());
    BOOST_REQUIRE_EQUAL("123.124.125.012", l_validator->def_value<std::string>("test.address"));
    BOOST_REQUIRE_EQUAL(true, l_validator->def_value<bool>("test.enabled"));
    BOOST_REQUIRE_EQUAL(1.5,  l_validator->def_value<double>("test.cost"));
    BOOST_REQUIRE_EQUAL(variant("x"), l_validator->def("test.section2.abc").data());
    BOOST_REQUIRE_THROW(l_validator->def("a.b.c"), variant_tree_error);

    variant_tree l_config("", l_validator);
    bool b = l_config.get<bool>("test.enabled");
    BOOST_REQUIRE(b);

    const config::option* l_opt = l_validator->find("enabled", "test");
    BOOST_REQUIRE(l_opt);
    BOOST_REQUIRE_EQUAL("enabled", l_opt->name);
    BOOST_REQUIRE_EQUAL(true, l_opt->default_value.data().to_bool());

    try {
        l_validator->def("name", "test.country");
        BOOST_REQUIRE(false);
    } catch (variant_tree_error& e) {
        BOOST_REQUIRE_EQUAL("test.country.name", e.path());
    }

    try   { l_validator->def("", "test.country.name"); }
    catch ( variant_tree_error& e )
          { BOOST_CHECK_EQUAL("", e.path()); }

    try   { l_validator->def("test.country.name"); }
    catch ( variant_tree_error& e )
          { BOOST_CHECK_EQUAL("test.country.name", e.path()); }

    std::string s = l_config.get<std::string>("test.tmp_str");
    BOOST_REQUIRE(s.find('$') == std::string::npos);
}
